---
title: 'Retrieve User Memory'
openapi: 'POST /user_memory/retrieve_user_memory'
---

## Overview

The Retrieve User Memory endpoint performs semantic search through a user's stored memories to find the most relevant information based on a query. This is the primary endpoint for accessing user memories in your AI applications, enabling context-aware responses and personalized interactions.

## Functionality

- **Semantic Search**: Uses advanced vector search to find memories that are semantically similar to your query
- **Relevance Ranking**: Returns memories ranked by relevance to the search query
- **Configurable Results**: Control the number of memories returned with the `max_count` parameter
- **Context-Aware**: Finds memories that are contextually relevant, not just keyword matches

## How Semantic Search Works

Unlike traditional keyword search, semantic search understands the meaning and context of your query. For example:
- Query: "authentication preferences" 
- Will find memories about: "JWT tokens", "login methods", "security settings", etc.
- Even if the exact words don't match

## Use Cases

- **Context Retrieval**: Get relevant user context before generating AI responses
- **Personalization**: Find user preferences and past interactions for tailored experiences
- **Memory-Based Chat**: Enable AI to reference past conversations and user history
- **Recommendation Systems**: Use user memories to provide personalized recommendations
- **Customer Support**: Access user history and preferences for better support

## Example Usage

### Basic Memory Retrieval

```bash
curl -X POST "https://api.cortex.com/user_memory/retrieve_user_memory?tenant_id=company_123&sub_tenant_id=engineering_team&max_count=5" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "authentication preferences"
  }'
```

### Response

```json
{
  "success": true,
  "user_memories": [
    {
      "source_id": "mem_001_abc123",
      "source_content": "User prefers JWT tokens over session-based authentication for microservices"
    },
    {
      "source_id": "mem_002_def456", 
      "source_content": "User values stateless authentication approaches"
    },
    {
      "source_id": "mem_003_ghi789",
      "source_content": "User understands the importance of rate limiting for security"
    }
  ]
}
```

### Advanced Usage: Context-Aware AI Response

```bash
# First, retrieve relevant memories
curl -X POST "https://api.cortex.com/user_memory/retrieve_user_memory?tenant_id=company_123&sub_tenant_id=product_team&max_count=3" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "user onboarding feedback"
  }'

# Then use these memories to generate a personalized response
```

### Different Query Examples

```bash
# Find communication preferences
curl -X POST "https://api.cortex.com/user_memory/retrieve_user_memory?tenant_id=company_123&sub_tenant_id=marketing_team&max_count=2" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "communication style preferences"
  }'

# Find technical expertise areas  
curl -X POST "https://api.cortex.com/user_memory/retrieve_user_memory?tenant_id=company_123&sub_tenant_id=engineering_team&max_count=5" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "technical skills and experience"
  }'

# Find project-related memories
curl -X POST "https://api.cortex.com/user_memory/retrieve_user_memory?tenant_id=company_123&sub_tenant_id=product_team&max_count=3" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "current project work"
  }'
```

## Important Notes

<Warning>
**Automatic Tenant Provisioning**: If you receive an error stating "Tenant-id/sub-tenant-id combination either does not exist or is not provisioned for user memory", this means the tenant/sub-tenant combination hasn't been set up for user memory functionality yet. This will be automatically provisioned when you add or generate your first user memory for this combination.
</Warning>

<Note>
**Empty Results**: If no relevant memories are found, the endpoint returns an empty array. This is normal for new users or when searching for topics not covered in existing memories.
</Note>

<Info>
**Query Optimization**: 
- Be specific about the type of information you're looking for
- Consider using synonyms or related terms if initial queries don't return results
- Shorter, focused queries often work better than long, complex ones
</Info>

<Tip>
**Pro Tip**: This endpoint is most powerful when used in combination with other user memory endpoints. Use [Generate User Memory](/api-reference/endpoint/generate-user-memory) to create memories from user interactions, then use this endpoint to retrieve relevant context for future interactions.
</Tip>

## Response Fields

| Field | Type | Description |
|-------|------|-------------|
| `success` | boolean | Indicates whether the operation was successful |
| `user_memories` | array | Array of relevant user memory objects, ranked by relevance |
| `user_memories[].source_id` | string | Unique identifier for the memory |
| `user_memories[].source_content` | string | The actual content of the memory |

## Parameters

### Query Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `tenant_id` | string | Yes | Primary organizational identifier |
| `sub_tenant_id` | string | No | Secondary organizational identifier (defaults to empty string) |
| `max_count` | integer | No | Maximum number of memories to return (default: 5, min: 0, max: 50) |

### Request Body Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `query` | string | Yes | Search query to find relevant memories |

## Error Responses

All endpoints return consistent error responses following the standard format. For detailed error information, see our [Error Responses](/api-reference/error-responses) documentation.

### Common Error Scenarios

**400 Bad Request**: Invalid input parameters or malformed requests
```json
{
  "detail": {
    "success": false,
    "message": "Invalid request parameters",
    "error_code": "INVALID_PARAMETERS"
  }
}
```

**401 Unauthorized**: Invalid or missing API key
```json
{
  "detail": {
    "success": false,
    "message": "Authentication required",
    "error_code": "UNAUTHORIZED"
  }
}
```

**403 Forbidden**: Valid authentication but insufficient permissions
```json
{
  "detail": {
    "success": false,
    "message": "Access denied",
    "error_code": "FORBIDDEN"
  }
}
```

**404 Not Found**: Requested resource does not exist
```json
{
  "detail": {
    "success": false,
    "message": "Resource not found",
    "error_code": "NOT_FOUND"
  }
}
```

**409 Conflict**: Resource already exists or conflicts with existing data
```json
{
  "detail": {
    "success": false,
    "message": "Resource already exists",
    "error_code": "CONFLICT"
  }
}
```

**422 Unprocessable Entity**: Request is well-formed but contains semantic errors
```json
{
  "detail": {
    "success": false,
    "message": "Validation failed",
    "error_code": "VALIDATION_ERROR"
  }
}
```

**500 Internal Server Error**: Unexpected server-side error
```json
{
  "detail": {
    "success": false,
    "message": "Internal server error",
    "error_code": "INTERNAL_ERROR"
  }
}
```

<Note>
**Error Handling**: Always check the `detail` object in error responses for the actual error information. The outer structure may vary, but the `detail` object always follows the standard format.
</Note>
